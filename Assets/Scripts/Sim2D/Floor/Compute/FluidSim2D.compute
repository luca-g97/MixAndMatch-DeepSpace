#pragma kernel ExternalForces
#pragma kernel UpdateSpatialHash
#pragma kernel Reorder
#pragma kernel ReorderCopyback
#pragma kernel CalculateDensities
#pragma kernel CalculatePressureForce
#pragma kernel CalculateViscosity
#pragma kernel UpdatePositions
#pragma kernel ResetCompactionCounter
#pragma kernel CompactAndMoveParticles
#pragma kernel CopyCollisionBuffer

#include "./FluidMaths2D.hlsl"
#include "./SpatialHash.hlsl"

#define FLT_MAX 3.402823466e+38
#define MAX_OBSTACLES 256

// --- Structs ---
struct Obstacle
{
    float2 centre;
    int vertexStart;
    int vertexCount;
    float lineWidth;
    int obstacleType;
};

struct Current
{
    int vertexStart;
    int vertexCount;
    float maxVelocity;
    float width;
    float linearFactor;
};

// --- Buffers ---
RWStructuredBuffer<float2> Positions;
RWStructuredBuffer<float2> PredictedPositions;
RWStructuredBuffer<float2> Velocities;
RWStructuredBuffer<float2> Densities;
RWStructuredBuffer<int4> CollisionBuffer;
RWStructuredBuffer<int2> ParticleTypeBuffer;
RWStructuredBuffer<uint> SpatialKeys;
RWStructuredBuffer<uint> SpatialOffsets;
RWStructuredBuffer<int4> CopiedCollisionBuffer_Destination;

StructuredBuffer<float> GravityScales;
StructuredBuffer<uint> SortedIndices;
StructuredBuffer<Obstacle> ObstaclesBuffer;
StructuredBuffer<float2> VerticesBuffer;
StructuredBuffer<Current> CurrentsBuffer;
StructuredBuffer<float2> CurrentVerticesBuffer;
StructuredBuffer<int4> OriginalCollisionBuffer_Source;

RWStructuredBuffer<float2> SortTarget_Positions;
RWStructuredBuffer<float2> SortTarget_PredictedPositions;
RWStructuredBuffer<float2> SortTarget_Velocities;
RWStructuredBuffer<int2> SortTarget_ParticleType;
RWStructuredBuffer<int4> SortTarget_Collision;
RWStructuredBuffer<uint> CompactionInfoBuffer;
StructuredBuffer<float4> ObstacleColorsBuffer;

StructuredBuffer<float2> Source_Positions;
StructuredBuffer<float2> Source_PredictedPositions;
StructuredBuffer<float2> Source_Velocities;
StructuredBuffer<int2> Source_ParticleType;
StructuredBuffer<int4> Source_Collision;

StructuredBuffer<float2> CopySource_Positions;
StructuredBuffer<float2> CopySource_PredictedPositions;
StructuredBuffer<float2> CopySource_Velocities;
StructuredBuffer<int2> CopySource_ParticleType;
StructuredBuffer<int4> CopySource_Collision;

// --- Global Variables ---
int numObstacles;
float areaToColorAroundObstacles;
float coloredAreaAroundObstaclesDivider;
float minDistanceToRemoveParticles;
static const int NumThreads = 64;
int numCurrents;

float4 mixableColors[12];
int mixableColorsSize;
float4 colorPalette[12];
int colorPaletteSize;

const uint numParticles;
const float gravity;
const float deltaTime;
const float collisionDamping;
const float smoothingRadius;

float waterTargetDensity;
float waterPressureMultiplier;
float waterNearPressureMultiplier;
float waterViscosityStrength;
float oilTargetDensity;
float oilPressureMultiplier;
float oilNearPressureMultiplier;
float oilViscosityStrength;

const float2 boundsSize;
const float yOffset;
const float2 interactionInputPoint;
const float interactionInputStrength;
const float interactionInputRadius;

const float mouseGravityStrength;
const float mouseGravityRadius;
const int invertMouseGravity;
const float2 mousePosition;
const int gKeyPressed;

// --- Helper Functions ---
float DensityKernel(float dst, float radius)
{
    return SpikyKernelPow2(dst, radius);
}
float NearDensityKernel(float dst, float radius)
{
    return SpikyKernelPow3(dst, radius);
}
float DensityDerivative(float dst, float radius)
{
    return DerivativeSpikyPow2(dst, radius);
}
float NearDensityDerivative(float dst, float radius)
{
    return DerivativeSpikyPow3(dst, radius);
}
float ViscosityKernel(float dst, float radius)
{
    return SmoothingKernelPoly6(dst, smoothingRadius);
}

float2 CalculateDensity(float2 pos)
{
    int2 originCell = GetCell2D(pos, smoothingRadius);
    float sqrRadius = smoothingRadius * smoothingRadius;
    float density = 0;
    float nearDensity = 0;

    for (int i = 0; i < 9; i++)
    {
        uint hash = HashCell2D(originCell + offsets2D[i]);
        uint key = KeyFromHash(hash, numParticles);
        uint currIndex = SpatialOffsets[key];

        while (currIndex < numParticles)
        {
            uint neighbourIndex = currIndex;
            currIndex++;

            uint neighbourKey = SpatialKeys[neighbourIndex];
            if (neighbourKey != key)
                break;

            float2 neighbourPos = PredictedPositions[neighbourIndex];
            float2 offsetToNeighbour = neighbourPos - pos;
            float sqrDstToNeighbour = dot(offsetToNeighbour, offsetToNeighbour);

            if (sqrDstToNeighbour > sqrRadius)
                continue;

            float dst = sqrt(sqrDstToNeighbour);
            density += DensityKernel(dst, smoothingRadius);
            nearDensity += NearDensityKernel(dst, smoothingRadius);
        }
    }

    return float2(density, nearDensity);
}

float PressureFromDensity(float density, float targetDensity, float pressureMultiplier)
{
    return (density - targetDensity) * pressureMultiplier;
}
float NearPressureFromDensity(float nearDensity, float nearPressureMultiplier)
{
    return nearPressureMultiplier * nearDensity;
}

float2 ExternalForcesFunc(float2 pos, float2 velocity, float gravityScale)
{
    float2 gravityAccel = float2(0, gravity * gravityScale);

    if (interactionInputStrength != 0)
    {
        float2 inputPointOffset = interactionInputPoint - pos;
        float sqrDst = dot(inputPointOffset, inputPointOffset);
        if (sqrDst < interactionInputRadius * interactionInputRadius)
        {
            float dst = sqrt(sqrDst);
            float edgeT = (dst / interactionInputRadius);
            float centreT = 1 - edgeT;
            float2 dirToCentre = inputPointOffset / max(dst, 0.0001);

            float2 interactionForce = dirToCentre * interactionInputStrength * centreT;
            gravityAccel += interactionForce;
            gravityAccel -= velocity * centreT * 0.5;
        }
    }

    return gravityAccel;
}

void HandleCollisions(uint particleIndex)
{
    float2 pos = Positions[particleIndex];
    float2 vel = Velocities[particleIndex];
    int particleType = ParticleTypeBuffer[particleIndex][0];
    int particleProcessFlag = ParticleTypeBuffer[particleIndex][1];

    if (particleType < 0)
    {
        const float2 halfSizeMinimal = boundsSize * 0.5;
        const float boundaryEpsilonMinimal = 0.001f;
        if (abs(pos.x) >= halfSizeMinimal.x)
        {
            pos.x = (halfSizeMinimal.x - boundaryEpsilonMinimal) * sign(pos.x);
            vel.x *= -collisionDamping;
        }
        if (abs(pos.y) >= halfSizeMinimal.y)
        {
            pos.y = (halfSizeMinimal.y - boundaryEpsilonMinimal) * sign(pos.y);
            vel.y *= -collisionDamping;
        }
        Positions[particleIndex] = pos;
        Velocities[particleIndex] = vel;
        return;
    }

    const float2 halfSize = boundsSize * 0.5;
    const float boundaryEpsilon = 0.001f;
    float areaToColorAroundObstaclesSq = areaToColorAroundObstacles * areaToColorAroundObstacles;
    float minDistanceToRemoveParticlesSq = minDistanceToRemoveParticles * minDistanceToRemoveParticles;
    float secondaryColorDist = areaToColorAroundObstacles + coloredAreaAroundObstaclesDivider;
    float secondaryColorDistSq = secondaryColorDist * secondaryColorDist;

    int collisionIndices[4] = { -1, -1, -1, -1 };
    int consideredObstacles = 0;

    if (abs(pos.x) >= halfSize.x)
    {
        pos.x = (halfSize.x - boundaryEpsilon) * sign(pos.x);
        vel.x *= -collisionDamping;
    }
    if (abs(pos.y) >= halfSize.y)
    {
        pos.y = (halfSize.y - boundaryEpsilon) * sign(pos.y);
        vel.y *= -collisionDamping;
    }

    [loop]
    for (int obstacleIdx = 0; obstacleIdx < numObstacles && obstacleIdx < MAX_OBSTACLES; obstacleIdx++)
    {
        Obstacle obstacle = ObstaclesBuffer[obstacleIdx];
        if (obstacle.vertexCount < 2)
            continue;

        int intersections = 0;
        float minDistSq = FLT_MAX;
        float2 normalAtClosestPoint = float2(0, 0);

        [loop]
        for (int j = 0; j < obstacle.vertexCount; j++)
        {
            int nextJ = (uint) (j + 1) % (uint) obstacle.vertexCount;
            float2 a = VerticesBuffer[obstacle.vertexStart + j];
            float2 b = VerticesBuffer[obstacle.vertexStart + nextJ];
            float2 edge = b - a;
            float2 vecToA = pos - a;

            float edgeLengthSq = dot(edge, edge);
            float2 pointOnEdge = a + clamp(dot(vecToA, edge) / max(edgeLengthSq, 1e-6f), 0.0, 1.0) * edge;

            float2 offsetToPoint = pos - pointOnEdge;
            float distSq = dot(offsetToPoint, offsetToPoint);

            if (distSq < minDistSq)
            {
                minDistSq = distSq;
                if (distSq > 1e-6f)
                {
                    normalAtClosestPoint = normalize(pos - pointOnEdge);
                }
                else
                {
                    float2 edgeDir = normalize(edge);
                    normalAtClosestPoint = normalize(float2(-edgeDir.y, edgeDir.x));
                }
            }

            if (obstacle.vertexCount >= 3 && ((a.y <= pos.y && pos.y < b.y) || (b.y <= pos.y && pos.y < a.y)))
            {
                if (abs(b.y - a.y) > 1e-6f)
                {
                    if (pos.x < a.x + (b.x - a.x) * (pos.y - a.y) / (b.y - a.y))
                    {
                        intersections++;
                    }
                }
            }
        }

        bool isInside = (obstacle.vertexCount >= 3) && ((uint(intersections) % 2) != 0);

        if (particleType > 0)
        {
            if (obstacle.obstacleType == 0)
            {
                if (consideredObstacles < 4)
                {
                    if (minDistSq < areaToColorAroundObstaclesSq)
                    {
                        collisionIndices[consideredObstacles] = obstacleIdx;
                        consideredObstacles++;
                    }
                    else if (minDistSq < secondaryColorDistSq)
                    {
                        collisionIndices[consideredObstacles] = -2;
                        consideredObstacles++;
                    }
                }

                if (particleProcessFlag == -1 && minDistSq <= minDistanceToRemoveParticlesSq)
                {
                    ParticleTypeBuffer[particleIndex][1] = obstacleIdx;
                    break;
                }
            }
            else if (obstacle.obstacleType == 2 && particleProcessFlag == -1 && isInside)
            {
                ParticleTypeBuffer[particleIndex][1] = -obstacleIdx - 2;
            }
        }
        
        float particleRadius = 0.1f;
        float collisionPadding = particleRadius - (obstacle.lineWidth * 0.5f);
        bool collisionDetected = isInside || (minDistSq < collisionPadding * collisionPadding);

        if (particleType >= 0 && collisionDetected && (obstacle.obstacleType == 0 || obstacle.obstacleType == 1))
        {
            float actualDistance = sqrt(minDistSq);
            float penetrationDepth = isInside ? (actualDistance + collisionPadding) : (collisionPadding - actualDistance);
            pos += normalAtClosestPoint * (penetrationDepth + 0.001f);

            float normalSpeed = dot(vel, normalAtClosestPoint);
            if (normalSpeed < 0)
            {
                float2 tangentVel = vel - normalAtClosestPoint * normalSpeed;
                float2 normalVel = -normalAtClosestPoint * normalSpeed * collisionDamping;
                float friction = 0.1f;
                vel = tangentVel * (1.0f - friction) + normalVel;
            }
        }
    }
    
    CollisionBuffer[particleIndex] = int4(collisionIndices[0], collisionIndices[1], collisionIndices[2], collisionIndices[3]);
    Positions[particleIndex] = pos;
    Velocities[particleIndex] = vel;
}

void ApplyCurrentForces(uint particleIndex, float2 pos)
{
    for (int currentIdx = 0; currentIdx < numCurrents; currentIdx++)
    {
        Current current = CurrentsBuffer[currentIdx];
        int numSegments = current.vertexCount - 1;

        if (numSegments < 1)
            continue;

        float maxStrength = 0;
        float2 closestDir = float2(0, 0);
        
        for (int segIdx = 0; segIdx < numSegments; segIdx++)
        {
            int pointIdx = current.vertexStart + segIdx;
            float2 a = CurrentVerticesBuffer[pointIdx];
            float2 b = CurrentVerticesBuffer[pointIdx + 1];

            float2 ab = b - a;
            float2 ap = pos - a;
            float lin_factor = clamp(dot(ap, ab) / dot(ab, ab), 0.0, 1.0);
            float2 closestPoint = a + lin_factor * ab;
            float2 toClosest = pos - closestPoint;
            float distSq = dot(toClosest, toClosest);

            if (distSq < current.width * current.width)
            {
                float dist = sqrt(distSq);
                float normalizedDist = dist / current.width;
                float strength = pow(abs(1.0 - normalizedDist), abs(1.0 + current.linearFactor));
                
                if (strength > maxStrength)
                {
                    maxStrength = strength;
                    closestDir = normalize(ab);
                }
            }
        }
        
        if (maxStrength > 0.001)
        {
            Velocities[particleIndex] += closestDir * current.maxVelocity * maxStrength;
        }
    }
}

// --- Kernel Entry Points ---
[numthreads(NumThreads, 1, 1)]
void ExternalForces(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= numParticles)
        return;
    float gravityScale = GravityScales[id.x];
    float2 pos = Positions[id.x];
    float2 toMouse = mousePosition - pos;
    float mouseDist = length(toMouse);
    if (mouseDist < mouseGravityRadius && mouseDist > 0 && gKeyPressed)
    {
        float2 mouseDir = toMouse / mouseDist;
        float falloff = 1 - (mouseDist / mouseGravityRadius);
        float mouseInfluence = mouseGravityStrength * falloff;
        if (invertMouseGravity)
            mouseInfluence *= -1;
        gravityScale += mouseInfluence;
    }
    Velocities[id.x] += ExternalForcesFunc(pos, Velocities[id.x], gravityScale) * deltaTime;
    PredictedPositions[id.x] = pos + Velocities[id.x] * (1 / 120.0);
}

[numthreads(NumThreads, 1, 1)]
void UpdateSpatialHash(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= numParticles)
        return;
    uint index = id.x;
    int2 cell = GetCell2D(PredictedPositions[index], smoothingRadius);
    uint hash = HashCell2D(cell);
    uint key = KeyFromHash(hash, numParticles);
    SpatialKeys[id.x] = key;
}

[numthreads(NumThreads, 1, 1)]
void Reorder(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= numParticles)
        return;
    uint sortedIndex = SortedIndices[id.x];
    SortTarget_Positions[id.x] = Source_Positions[sortedIndex];
    SortTarget_PredictedPositions[id.x] = Source_PredictedPositions[sortedIndex];
    SortTarget_Velocities[id.x] = Source_Velocities[sortedIndex];
    SortTarget_ParticleType[id.x] = Source_ParticleType[sortedIndex];
    SortTarget_Collision[id.x] = Source_Collision[sortedIndex];
}

[numthreads(NumThreads, 1, 1)]
void ReorderCopyback(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= numParticles)
        return;
    Positions[id.x] = CopySource_Positions[id.x];
    PredictedPositions[id.x] = CopySource_PredictedPositions[id.x];
    Velocities[id.x] = CopySource_Velocities[id.x];
    ParticleTypeBuffer[id.x] = CopySource_ParticleType[id.x];
    CollisionBuffer[id.x] = CopySource_Collision[id.x];
}

[numthreads(NumThreads, 1, 1)]
void CalculateDensities(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= numParticles || ParticleTypeBuffer[id.x][0] == -1)
        return;
    float2 pos = PredictedPositions[id.x];
    Densities[id.x] = CalculateDensity(pos);
}

[numthreads(NumThreads, 1, 1)]
void CalculatePressureForce(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= numParticles || ParticleTypeBuffer[id.x][0] == -1)
        return;
    float targetDensity = ParticleTypeBuffer[id.x][0] == 0 ? waterTargetDensity : oilTargetDensity;
    float pressureMultiplier = ParticleTypeBuffer[id.x][0] == 0 ? waterPressureMultiplier : oilPressureMultiplier;
    float nearPressureMultiplier = ParticleTypeBuffer[id.x][0] == 0 ? waterNearPressureMultiplier : oilNearPressureMultiplier;
    float density = Densities[id.x][0];
    float densityNear = Densities[id.x][1];
    float pressure = PressureFromDensity(density, targetDensity, pressureMultiplier);
    float nearPressure = NearPressureFromDensity(densityNear, nearPressureMultiplier);
    float2 pressureForce = 0;
    float2 pos = PredictedPositions[id.x];
    int2 originCell = GetCell2D(pos, smoothingRadius);
    float sqrRadius = smoothingRadius * smoothingRadius;
    for (int i = 0; i < 9; i++)
    {
        uint hash = HashCell2D(originCell + offsets2D[i]);
        uint key = KeyFromHash(hash, numParticles);
        uint currIndex = SpatialOffsets[key];
        while (currIndex < numParticles)
        {
            uint neighbourIndex = currIndex;
            currIndex++;
            if (neighbourIndex == id.x)
                continue;
            uint neighbourKey = SpatialKeys[neighbourIndex];
            if (neighbourKey != key)
                break;
            float2 neighbourPos = PredictedPositions[neighbourIndex];
            float2 offsetToNeighbour = neighbourPos - pos;
            float sqrDstToNeighbour = dot(offsetToNeighbour, offsetToNeighbour);
            if (sqrDstToNeighbour > sqrRadius)
                continue;
            float neighbourDensity = Densities[neighbourIndex][0];
            if (neighbourDensity < 0.0001)
                continue;
            float neighbourNearDensity = Densities[neighbourIndex][1];
            if (neighbourNearDensity < 0.0001)
                continue;
            float dst = sqrt(sqrDstToNeighbour);
            float2 dirToNeighbour = dst > 0 ? offsetToNeighbour / dst : float2(0, 1);
            float neighbourTargetDensity = ParticleTypeBuffer[neighbourIndex][0] == 0 ? waterTargetDensity : oilTargetDensity;
            float neighbourPressureMultiplier = ParticleTypeBuffer[neighbourIndex][0] == 0 ? waterPressureMultiplier : oilPressureMultiplier;
            float neighbourNearPressureMultiplier = ParticleTypeBuffer[neighbourIndex][0] == 0 ? waterNearPressureMultiplier : oilNearPressureMultiplier;
            float neighbourPressure = PressureFromDensity(neighbourDensity, neighbourTargetDensity - density, neighbourPressureMultiplier);
            float neighbourNearPressure = NearPressureFromDensity(neighbourNearDensity, neighbourNearPressureMultiplier);
            float sharedPressure = (pressure + neighbourPressure) * 0.5;
            float sharedNearPressure = (nearPressure + neighbourNearPressure) * 0.5;
            pressureForce += dirToNeighbour * DensityDerivative(dst, smoothingRadius) * sharedPressure / neighbourDensity;
            pressureForce += dirToNeighbour * NearDensityDerivative(dst, smoothingRadius) * sharedNearPressure / neighbourNearDensity;
        }
    }
    if (density < 0.0001)
        return;
    float2 acceleration = pressureForce / density;
    Velocities[id.x] += acceleration * deltaTime;
}

[numthreads(NumThreads, 1, 1)]
void CalculateViscosity(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= numParticles || ParticleTypeBuffer[id.x][0] == -1)
        return;
    if (Densities[id.x][0] < 0.0001)
        return;
    float2 pos = PredictedPositions[id.x];
    int2 originCell = GetCell2D(pos, smoothingRadius);
    float sqrRadius = smoothingRadius * smoothingRadius;
    float2 viscosityForce = 0;
    float2 velocity = Velocities[id.x];
    for (int i = 0; i < 9; i++)
    {
        uint hash = HashCell2D(originCell + offsets2D[i]);
        uint key = KeyFromHash(hash, numParticles);
        uint currIndex = SpatialOffsets[key];
        while (currIndex < numParticles)
        {
            uint neighbourIndex = currIndex;
            currIndex++;
            if (neighbourIndex == id.x)
                continue;
            uint neighbourKey = SpatialKeys[neighbourIndex];
            if (neighbourKey != key)
                break;
            float2 neighbourPos = PredictedPositions[neighbourIndex];
            float2 offsetToNeighbour = neighbourPos - pos;
            float sqrDstToNeighbour = dot(offsetToNeighbour, offsetToNeighbour);
            if (sqrDstToNeighbour > sqrRadius)
                continue;
            float dst = sqrt(sqrDstToNeighbour);
            float2 neighbourVelocity = Velocities[neighbourIndex];
            viscosityForce += (neighbourVelocity - velocity) * ViscosityKernel(dst, smoothingRadius);
        }
    }
    float viscosityStrength = ParticleTypeBuffer[id.x][0] == 0 ? waterViscosityStrength : oilViscosityStrength;
    Velocities[id.x] += viscosityForce * viscosityStrength * deltaTime;
}

[numthreads(NumThreads, 1, 1)]
void UpdatePositions(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= numParticles)
        return;
    ApplyCurrentForces(id.x, Positions[id.x]);
    HandleCollisions(id.x);
    Positions[id.x] += Velocities[id.x] * deltaTime;
}

[numthreads(1, 1, 1)]
void ResetCompactionCounter(uint3 id : SV_DispatchThreadID)
{
    CompactionInfoBuffer[0] = 0;
}

[numthreads(NumThreads, 1, 1)]
void CompactAndMoveParticles(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= numParticles)
        return;
    int particleTypeIndex = Source_ParticleType[id.x].x;
    int removalFlag = Source_ParticleType[id.x].y;
    bool shouldKeep = true;

    if (removalFlag <= -2)
    {
        shouldKeep = false;
    }
    else if (removalFlag >= 0)
    {
        if (particleTypeIndex > 0)
        {
            int particleColorIndex = particleTypeIndex - 1;
            float3 particleVisualColor = mixableColors[particleColorIndex].rgb;
            int4 nearbyObstacleIndices = Source_Collision[id.x];
            float3 uniqueColors[4];
            int uniqueColorCount = 0;
            for (int i = 0; i < 4; i++)
            {
                int obsIndex = nearbyObstacleIndices[i];
                if (obsIndex >= 0)
                {
                    float3 obsColor = ObstacleColorsBuffer[obsIndex].rgb;
                    bool alreadyFound = false;
                    for (int j = 0; j < uniqueColorCount; j++)
                    {
                        if (distance(obsColor, uniqueColors[j]) < 0.001)
                        {
                            alreadyFound = true;
                            break;
                        }
                    }
                    if (!alreadyFound && uniqueColorCount < 4)
                    {
                        uniqueColors[uniqueColorCount] = obsColor;
                        uniqueColorCount++;
                    }
                }
            }
            if (uniqueColorCount > 0)
            {
                float3 blendedColorSum = float3(0, 0, 0);
                for (int i = 0; i < uniqueColorCount; i++)
                {
                    blendedColorSum += uniqueColors[i];
                }
                float3 blendedColorAverage = blendedColorSum / uniqueColorCount;
                if (distance(blendedColorAverage, particleVisualColor) < 0.02)
                {
                    shouldKeep = false;
                }
            }
        }
    }

    if (shouldKeep)
    {
        uint newIndex;
        InterlockedAdd(CompactionInfoBuffer[0], 1, newIndex);
        SortTarget_Positions[newIndex] = Source_Positions[id.x];
        SortTarget_PredictedPositions[newIndex] = Source_PredictedPositions[id.x];
        SortTarget_Velocities[newIndex] = Source_Velocities[id.x];
        SortTarget_Collision[newIndex] = Source_Collision[id.x];
        int2 currentParticleTypeInfo = Source_ParticleType[id.x];
        currentParticleTypeInfo.y = -1;
        SortTarget_ParticleType[newIndex] = currentParticleTypeInfo;
    }
}

[numthreads(64, 1, 1)]
void CopyCollisionBuffer(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= numParticles)
        return;
    CopiedCollisionBuffer_Destination[id.x] = OriginalCollisionBuffer_Source[id.x];
}