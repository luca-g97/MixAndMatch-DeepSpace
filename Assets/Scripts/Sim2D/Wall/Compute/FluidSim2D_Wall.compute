#pragma kernel ExternalForces_Wall
#pragma kernel UpdateSpatialHash_Wall
#pragma kernel Reorder_Wall
#pragma kernel ReorderCopyback_Wall
#pragma kernel CalculateDensities_Wall
#pragma kernel CalculatePressureForce_Wall
#pragma kernel CalculateViscosity_Wall
#pragma kernel UpdatePositions_Wall
#pragma kernel ResetCompactionCounter_Wall
#pragma kernel CompactAndMoveParticles_Wall
#pragma kernel CopyParticleTypeBuffer_Wall
#pragma kernel ClearRemovedParticlesBuffer_Wall
#pragma kernel ClearObstacleGrid_Wall
#pragma kernel BuildObstacleGrid_Wall

#include "./FluidMaths2D_Wall.hlsl"
#include "./SpatialHash_Wall.hlsl"

#define FLT_MAX 3.402823466e+38
#define MAX_OBSTACLES 256

struct ParticleData
{
    float2 position;
    float2 predictedPosition;
    float2 velocity;
    int2 particleType;
    int4 collision;
    float2 density;
    float gravityScale;
    float padding; // To match the C# struct layout
};

struct Obstacle
{
    float2 centre;
    int vertexStart;
    int vertexCount;
    float lineWidth;
    int obstacleType;
    float4 aabb;
};

struct Current
{
    int vertexStart;
    int vertexCount;
    float maxVelocity;
    float width;
    float linearFactor;
};

// Buffers used across many kernels (can be RW)
RWStructuredBuffer<float2> Positions_Wall;
RWStructuredBuffer<float2> PredictedPositions_Wall;
RWStructuredBuffer<float2> Velocities_Wall;
RWStructuredBuffer<float2> Densities_Wall;
RWStructuredBuffer<float> GravityScales_Wall;
RWStructuredBuffer<int4> CollisionBuffer_Wall;
RWStructuredBuffer<int2> ParticleTypeBuffer_Wall;
RWStructuredBuffer<uint> SpatialKeys_Wall;
RWStructuredBuffer<uint> SpatialOffsets_Wall;
RWStructuredBuffer<int4> CopiedParticleTypeBuffer_Destination_Wall;

// Buffers that are read-only in most contexts
StructuredBuffer<uint> SortedIndices_Wall;
StructuredBuffer<Obstacle> ObstaclesBuffer_Wall;
StructuredBuffer<float2> VerticesBuffer_Wall;
StructuredBuffer<Current> CurrentsBuffer_Wall;
StructuredBuffer<float2> CurrentVerticesBuffer_Wall;
StructuredBuffer<int4> OriginalParticleTypeBuffer_Source_Wall;

// --- Buffers for Compaction Kernel ---
// NOTE: These are the destinations, so they MUST be RW (UAVs)
RWStructuredBuffer<ParticleData> SortTarget_Data_Wall;

// This is the atomic counter, it MUST be RW (UAV)
RWStructuredBuffer<int2> CompactionInfoBuffer_Wall;
RWStructuredBuffer<float4> RemovedParticlesBuffer_Wall;

StructuredBuffer<float2> Source_Positions_Wall;
StructuredBuffer<float2> Source_PredictedPositions_Wall;
StructuredBuffer<float2> Source_Velocities_Wall;
StructuredBuffer<float2> Source_Densities_Wall;
StructuredBuffer<float> Source_GravityScales_Wall;
StructuredBuffer<int2> Source_ParticleType_Wall;

// Aliases for the REORDERCOPYBACK kernel's source data
StructuredBuffer<ParticleData> CopySource_Data_Wall;

RWStructuredBuffer<uint> ObstacleGridCounts_Wall;
RWStructuredBuffer<uint> ObstacleGrid_Wall;

float obstacleGridCellSize_Wall;
int2 obstacleGridDims_Wall;
int maxObstaclesPerCell_Wall;

int numObstacles_Wall;
static const int NumThreads_Wall = 64;
int numCurrents_Wall;

const uint numParticles_Wall;
const float gravity_Wall;
const float deltaTime_Wall;
const float collisionDamping_Wall;
const float smoothingRadius_Wall;

float waterTargetDensity_Wall;
float waterPressureMultiplier_Wall;
float waterNearPressureMultiplier_Wall;
float waterViscosityStrength_Wall;
float oilTargetDensity_Wall;
float oilPressureMultiplier_Wall;
float oilNearPressureMultiplier_Wall;
float oilViscosityStrength_Wall;

const float2 boundsSize_Wall;
const float yOffset_Wall;

float DensityKernel_Wall(float dst, float radius)
{
    return SpikyKernelPow2_Wall(dst, radius);
}
float NearDensityKernel_Wall(float dst, float radius)
{
    return SpikyKernelPow3_Wall(dst, radius);
}
float DensityDerivative_Wall(float dst, float radius)
{
    return DerivativeSpikyPow2_Wall(dst, radius);
}
float NearDensityDerivative_Wall(float dst, float radius)
{
    return DerivativeSpikyPow3_Wall(dst, radius);
}
float ViscosityKernel_Wall(float dst, float radius)
{
    return SmoothingKernelPoly6_Wall(dst, smoothingRadius_Wall);
}

float ViscosityKernelSqr_Wall(float sqrDst, float sqrRadius)
{
    float val = max(0, sqrRadius - sqrDst);
    return Poly6ScalingFactor_Wall * val * val * val;
}

float2 CalculateDensity_Wall(float2 pos)
{
    int2 originCell = GetCell2D_Wall(pos, smoothingRadius_Wall);
    float sqrRadius = smoothingRadius_Wall * smoothingRadius_Wall;
    float density = 0;
    float nearDensity = 0;

    for (int i = 0; i < 9; i++)
    {
        uint hash = HashCell2D_Wall(originCell + offsets2D_Wall[i]);
        uint key = KeyFromHash_Wall(hash, numParticles_Wall);
        uint currIndex = SpatialOffsets_Wall[key];

        while (currIndex < numParticles_Wall)
        {
            uint neighbourIndex = currIndex;
            currIndex++;

            uint neighbourKey = SpatialKeys_Wall[neighbourIndex];
            if (neighbourKey != key)
                break;

            float2 neighbourPos = PredictedPositions_Wall[neighbourIndex];
            float2 offsetToNeighbour = neighbourPos - pos;
            float sqrDstToNeighbour = dot(offsetToNeighbour, offsetToNeighbour);

            if (sqrDstToNeighbour > sqrRadius)
                continue;

            float dst = sqrt(sqrDstToNeighbour);
            density += DensityKernel_Wall(dst, smoothingRadius_Wall);
            nearDensity += NearDensityKernel_Wall(dst, smoothingRadius_Wall);
        }
    }

    return float2(density, nearDensity);
}

float PressureFromDensity_Wall(float density, float targetDensity, float pressureMultiplier)
{
    return (density - targetDensity) * pressureMultiplier;
}
float NearPressureFromDensity_Wall(float nearDensity, float nearPressureMultiplier)
{
    return nearPressureMultiplier * nearDensity;
}

float2 ExternalForces_Wall(float2 pos, float2 velocity, float gravityScale)
{
    return float2(0, gravity_Wall * gravityScale);
}

void HandleCollisions_Wall(uint particleIndex)
{
    // Get initial particle data
    float2 pos = Positions_Wall[particleIndex];
    float2 vel = Velocities_Wall[particleIndex];
    int particleType = ParticleTypeBuffer_Wall[particleIndex][0];
    // Read the removal flag once at the start
    int particleProcessFlag = ParticleTypeBuffer_Wall[particleIndex][1];

    // --- 1. BOUNDARY COLLISIONS (Your original logic) ---
    const float2 halfSize = boundsSize_Wall * 0.5;
    const float boundaryEpsilon = 0.001f;

    if (abs(pos.x) >= halfSize.x)
    {
        pos.x = (halfSize.x - boundaryEpsilon) * sign(pos.x);
        vel.x *= -collisionDamping_Wall;
    }
    if (pos.y >= halfSize.y + yOffset_Wall)
    {
        pos.y = (halfSize.y - boundaryEpsilon) * sign(pos.y) + yOffset_Wall;
        vel.y *= -collisionDamping_Wall;
    }
    if (pos.y <= -halfSize.y + yOffset_Wall)
    {
        pos.y = (-halfSize.y - boundaryEpsilon) * sign(pos.y) + yOffset_Wall;
        vel.y *= -collisionDamping_Wall;
    }
    
    // --- 2. OBSTACLE COLLISIONS (Using the Grid) ---
    // Find which grid cell the particle is in
    int2 particleCellCoords = (int2) floor(pos / obstacleGridCellSize_Wall);
    
    // Loop through the 3x3 neighborhood of cells around the particle
    for (int y = -1; y <= 1; y++)
    {
        for (int x = -1; x <= 1; x++)
        {
            int2 sampleCellCoords = particleCellCoords + int2(x, y);

            // Check if the neighboring cell is within the grid bounds
            if (sampleCellCoords.x >= 0 && sampleCellCoords.x < obstacleGridDims_Wall.x && sampleCellCoords.y >= 0 && sampleCellCoords.y < obstacleGridDims_Wall.y)
            {
                uint cellIndex = (uint) (sampleCellCoords.y * obstacleGridDims_Wall.x + sampleCellCoords.x);
                
                // Get the number of obstacles in this cell from the counts buffer
                uint numLocalObstacles = min((uint) maxObstaclesPerCell_Wall, ObstacleGridCounts_Wall[cellIndex]);
                uint gridStartIndex = cellIndex * maxObstaclesPerCell_Wall;

                // Loop through ONLY the local obstacles found in this cell
                for (uint i = 0; i < numLocalObstacles; i++)
                {
                    // Get the actual index of the obstacle from the grid contents
                    uint obstacleIndex = ObstacleGrid_Wall[gridStartIndex + i];
                    Obstacle obstacle = ObstaclesBuffer_Wall[obstacleIndex];
                    
                    // --- 2a. BROAD PHASE (AABB Check) ---
                    if (pos.x < obstacle.aabb.x || pos.x > obstacle.aabb.z || pos.y < obstacle.aabb.y || pos.y > obstacle.aabb.w)
                    {
                        continue; // Fast reject, skip to next local obstacle
                    }
                    
                    // --- 2b. NARROW PHASE (Your original, precise logic) ---
                    // This code only runs for the few particles that pass the AABB check.
                    int intersections = 0;
                    float minDistSq = FLT_MAX;
                    float2 normalAtClosestPoint = float2(0, 0);

                    [loop]
                    for (int j = 0; j < obstacle.vertexCount; j++)
                    {
                        int nextJ = (uint) (j + 1) % (uint) obstacle.vertexCount;
                        float2 a = VerticesBuffer_Wall[obstacle.vertexStart + j];
                        float2 b = VerticesBuffer_Wall[obstacle.vertexStart + nextJ];
                        float2 edge = b - a;
                        float2 vecToA = pos - a;

                        float edgeLengthSq = dot(edge, edge);
                        float2 pointOnEdge = a + clamp(dot(vecToA, edge) / max(edgeLengthSq, 1e-6f), 0.0, 1.0) * edge;
                        
                        float2 offsetToPoint = pos - pointOnEdge;
                        float distSq = dot(offsetToPoint, offsetToPoint);

                        if (distSq < minDistSq)
                        {
                            minDistSq = distSq;
                            if (distSq > 1e-6f)
                            {
                                normalAtClosestPoint = normalize(pos - pointOnEdge);
                            }
                            else
                            {
                                float2 edgeDir = normalize(edge);
                                normalAtClosestPoint = normalize(float2(-edgeDir.y, edgeDir.x));
                            }
                        }

                        if (obstacle.vertexCount >= 3 && ((a.y <= pos.y && pos.y < b.y) || (b.y <= pos.y && pos.y < a.y)))
                        {
                            if (abs(b.y - a.y) > 1e-6f)
                            {
                                if (pos.x < a.x + (b.x - a.x) * (pos.y - a.y) / (b.y - a.y))
                                {
                                    intersections++;
                                }
                            }
                        }
                    } // --- End Vertex Loop ---

                    bool isInside = (obstacle.vertexCount >= 3) && ((uint(intersections) % 2) != 0);
                    
                    // --- Particle Removal Logic (Ventil) ---
                    if (particleType > 0)
                    {
                        // Use the flag we read at the start of the function
                        if (obstacle.obstacleType == 2 && particleProcessFlag == -1 && isInside)
                        {
                            // Flag the particle for removal. The 'obstacleIndex' cast is safe.
                            ParticleTypeBuffer_Wall[particleIndex][1] = (int) obstacleIndex;
                            // We can break here to stop checking other local obstacles, since it's going to be removed anyway
                            break;
                        }
                    }

                    // --- Collision Response Logic (Static Obstacles) ---
                    if (particleType >= 0 && (isInside || (minDistSq < 0.0001f)) && obstacle.obstacleType == 1)
                    {
                        float penetrationDepth = 0;
                        if (isInside)
                        {
                            penetrationDepth = sqrt(minDistSq);
                        }
                        
                        pos += normalAtClosestPoint * (penetrationDepth + 0.001f);
                        float normalSpeed = dot(vel, normalAtClosestPoint);
                        if (normalSpeed < 0)
                        {
                            vel -= normalAtClosestPoint * normalSpeed * (1 + collisionDamping_Wall);
                        }
                    } // --- End Collision Response ---
                } // --- End Local Obstacle Loop ---
            } // --- End Valid Cell Check ---
        } // --- End Neighborhood X-Loop ---
    } // --- End Neighborhood Y-Loop ---

    // --- 3. WRITE BACK FINAL DATA ---
    Positions_Wall[particleIndex] = pos;
    Velocities_Wall[particleIndex] = vel;
}

[numthreads(NumThreads_Wall, 1, 1)]
void ExternalForces_Wall(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= numParticles_Wall)
        return;

    float gravityScale = GravityScales_Wall[id.x];
    float2 pos = Positions_Wall[id.x];

    Velocities_Wall[id.x] += ExternalForces_Wall(pos, Velocities_Wall[id.x], gravityScale) * deltaTime_Wall;
    PredictedPositions_Wall[id.x] = pos + Velocities_Wall[id.x] * (1 / 120.0);
}

[numthreads(NumThreads_Wall, 1, 1)]
void UpdateSpatialHash_Wall(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= numParticles_Wall)
        return;
    uint index = id.x;
    int2 cell = GetCell2D_Wall(PredictedPositions_Wall[index], smoothingRadius_Wall);
    uint hash = HashCell2D_Wall(cell);
    uint key = KeyFromHash_Wall(hash, numParticles_Wall);
    SpatialKeys_Wall[id.x] = key;
}

void ApplyCurrentForces_Wall(uint particleIndex, float2 pos)
{
    for (int currentIdx = 0; currentIdx < numCurrents_Wall; currentIdx++)
    {
        Current current = CurrentsBuffer_Wall[currentIdx];
        int numSegments = current.vertexCount - 1;
        
        if (numSegments < 1)
            continue;
        
        float closestDistSq = FLT_MAX;
        float2 closestDir = float2(0, 0);
        float maxStrength = 0;
        
        for (int segIdx = 0; segIdx < numSegments; segIdx++)
        {
            int pointIdx = current.vertexStart + segIdx;
            float2 a = CurrentVerticesBuffer_Wall[pointIdx];
            float2 b = CurrentVerticesBuffer_Wall[pointIdx + 1];
            
            float2 ab = b - a;
            float2 ap = pos - a;
            float lin_factor = clamp(dot(ap, ab) / dot(ab, ab), 0.0, 1.0);
            float2 closestPoint = a + lin_factor * ab;
            float2 toClosest = pos - closestPoint;
            float distSq = dot(toClosest, toClosest);
            
            if (distSq < current.width * current.width)
            {
                float dist = sqrt(distSq);
                float normalizedDist = dist / current.width;
                float strength = pow(abs(1.0 - normalizedDist), abs(1.0 + current.linearFactor));
                
                if (strength > maxStrength)
                {
                    maxStrength = strength;
                    closestDir = normalize(ab);
                    closestDistSq = distSq;
                }
            }
        }
        
        if (maxStrength > 0.001)
        {
            Velocities_Wall[particleIndex] += closestDir * current.maxVelocity * maxStrength;
        }
    }
}

[numthreads(NumThreads_Wall, 1, 1)]
void Reorder_Wall(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= numParticles_Wall)
        return;
    
    uint sortedIndex = SortedIndices_Wall[id.x];

    // Assemble the struct and write it once
    ParticleData p;
    p.position = Source_Positions_Wall[sortedIndex];
    p.predictedPosition = Source_PredictedPositions_Wall[sortedIndex];
    p.velocity = Source_Velocities_Wall[sortedIndex];
    p.particleType = Source_ParticleType_Wall[sortedIndex];
    p.collision = int4(-1, -1, -1, -1);
    p.density = Source_Densities_Wall[sortedIndex];
    p.gravityScale = Source_GravityScales_Wall[sortedIndex];
    p.padding = 0;
    
    SortTarget_Data_Wall[id.x] = p;
}

[numthreads(NumThreads_Wall, 1, 1)]
void ReorderCopyback_Wall(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= numParticles_Wall)
        return;

    // Read the struct once and unpack it
    ParticleData p = CopySource_Data_Wall[id.x];
    
    Positions_Wall[id.x] = p.position;
    PredictedPositions_Wall[id.x] = p.predictedPosition;
    Velocities_Wall[id.x] = p.velocity;
    ParticleTypeBuffer_Wall[id.x] = p.particleType;
    Densities_Wall[id.x] = p.density;
    GravityScales_Wall[id.x] = p.gravityScale;
}

[numthreads(NumThreads_Wall, 1, 1)]
void CalculateDensities_Wall(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= numParticles_Wall || ParticleTypeBuffer_Wall[id.x][0] == -1)
        return;
    float2 pos = PredictedPositions_Wall[id.x];
    Densities_Wall[id.x] = CalculateDensity_Wall(pos);
}

[numthreads(NumThreads_Wall, 1, 1)]
void CalculatePressureForce_Wall(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= numParticles_Wall || ParticleTypeBuffer_Wall[id.x][0] == -1)
        return;
    
    float targetDensity = ParticleTypeBuffer_Wall[id.x][0] == 0 ? waterTargetDensity_Wall : oilTargetDensity_Wall;
    float pressureMultiplier = ParticleTypeBuffer_Wall[id.x][0] == 0 ? waterPressureMultiplier_Wall : oilPressureMultiplier_Wall;
    float nearPressureMultiplier = ParticleTypeBuffer_Wall[id.x][0] == 0 ? waterNearPressureMultiplier_Wall : oilNearPressureMultiplier_Wall;
    
    float density = Densities_Wall[id.x][0];
    float densityNear = Densities_Wall[id.x][1];
    float pressure = PressureFromDensity_Wall(density, targetDensity, pressureMultiplier);
    float nearPressure = NearPressureFromDensity_Wall(densityNear, nearPressureMultiplier);
    float2 pressureForce = 0;

    float2 pos = PredictedPositions_Wall[id.x];
    int2 originCell = GetCell2D_Wall(pos, smoothingRadius_Wall);
    float sqrRadius = smoothingRadius_Wall * smoothingRadius_Wall;

    for (int i = 0; i < 9; i++)
    {
        uint hash = HashCell2D_Wall(originCell + offsets2D_Wall[i]);
        uint key = KeyFromHash_Wall(hash, numParticles_Wall);
        uint currIndex = SpatialOffsets_Wall[key];

        while (currIndex < numParticles_Wall)
        {
            uint neighbourIndex = currIndex;
            currIndex++;

            if (neighbourIndex == id.x)
                continue;
            uint neighbourKey = SpatialKeys_Wall[neighbourIndex];
            if (neighbourKey != key)
                break;

            float2 neighbourPos = PredictedPositions_Wall[neighbourIndex];
            float2 offsetToNeighbour = neighbourPos - pos;
            float sqrDstToNeighbour = dot(offsetToNeighbour, offsetToNeighbour);

            if (sqrDstToNeighbour > sqrRadius)
                continue;
                
            // --- SAFETY CHECKS FOR NEIGHBOUR DENSITY ---
            float neighbourDensity = Densities_Wall[neighbourIndex][0];
            if (neighbourDensity < 0.0001)
            {
                continue;
            }
            float neighbourNearDensity = Densities_Wall[neighbourIndex][1];
            if (neighbourNearDensity < 0.0001)
            {
                continue;
            }
            // ------------------------------------------
            
            float dst = sqrt(sqrDstToNeighbour);
            float2 dirToNeighbour = dst > 0 ? offsetToNeighbour / dst : float2(0, 1);
            
            float neighbourTargetDensity = ParticleTypeBuffer_Wall[neighbourIndex][0] == 0 ? waterTargetDensity_Wall : oilTargetDensity_Wall;
            float neighbourPressureMultiplier = ParticleTypeBuffer_Wall[neighbourIndex][0] == 0 ? waterPressureMultiplier_Wall : oilPressureMultiplier_Wall;
            float neighbourNearPressureMultiplier = ParticleTypeBuffer_Wall[neighbourIndex][0] == 0 ? waterNearPressureMultiplier_Wall : oilNearPressureMultiplier_Wall;

            float neighbourPressure = PressureFromDensity_Wall(neighbourDensity, neighbourTargetDensity - density, neighbourPressureMultiplier);
            float neighbourNearPressure = NearPressureFromDensity_Wall(neighbourNearDensity, neighbourNearPressureMultiplier);

            float sharedPressure = (pressure + neighbourPressure) * 0.5;
            float sharedNearPressure = (nearPressure + neighbourNearPressure) * 0.5;

            pressureForce += dirToNeighbour * DensityDerivative_Wall(dst, smoothingRadius_Wall) * sharedPressure / neighbourDensity;
            pressureForce += dirToNeighbour * NearDensityDerivative_Wall(dst, smoothingRadius_Wall) * sharedNearPressure / neighbourNearDensity;
        }
    }

    // --- SAFETY CHECK FOR OWN DENSITY ---
    if (density < 0.0001)
    {
        return; // Particle is isolated, no pressure force to apply.
    }
    // ------------------------------------
    
    float2 acceleration = pressureForce / density;
    Velocities_Wall[id.x] += acceleration * deltaTime_Wall;
}

[numthreads(NumThreads_Wall, 1, 1)]
void CalculateViscosity_Wall(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= numParticles_Wall || ParticleTypeBuffer_Wall[id.x][0] == -1)
        return;
    if (Densities_Wall[id.x][0] < 0.0001)
        return;

    float2 pos = PredictedPositions_Wall[id.x];
    int2 originCell = GetCell2D_Wall(pos, smoothingRadius_Wall);
    float sqrRadius = smoothingRadius_Wall * smoothingRadius_Wall;
    float2 viscosityForce = 0;
    float2 velocity = Velocities_Wall[id.x];

    for (int i = 0; i < 9; i++)
    {
        uint hash = HashCell2D_Wall(originCell + offsets2D_Wall[i]);
        uint key = KeyFromHash_Wall(hash, numParticles_Wall);
        uint currIndex = SpatialOffsets_Wall[key];

        while (currIndex < numParticles_Wall)
        {
            uint neighbourIndex = currIndex;
            currIndex++;

            if (neighbourIndex == id.x)
                continue;

            uint neighbourKey = SpatialKeys_Wall[neighbourIndex];
            if (neighbourKey != key)
                break;

            float2 neighbourPos = PredictedPositions_Wall[neighbourIndex];
            float2 offsetToNeighbour = neighbourPos - pos;
            float sqrDstToNeighbour = dot(offsetToNeighbour, offsetToNeighbour);

            if (sqrDstToNeighbour < sqrRadius)
            {
                // Use the new, faster function with squared distance
                float2 neighbourVelocity = Velocities_Wall[neighbourIndex];
                viscosityForce += (neighbourVelocity - velocity) * ViscosityKernelSqr_Wall(sqrDstToNeighbour, sqrRadius);
            }
        }
    }

    float viscosityStrength = ParticleTypeBuffer_Wall[id.x][0] == 0 ? waterViscosityStrength_Wall : oilViscosityStrength_Wall;
    Velocities_Wall[id.x] += viscosityForce * viscosityStrength * deltaTime_Wall;
}

[numthreads(NumThreads_Wall, 1, 1)]
void UpdatePositions_Wall(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= numParticles_Wall)
        return;
    
    ApplyCurrentForces_Wall(id.x, Positions_Wall[id.x]);
    HandleCollisions_Wall(id.x);
    
    Positions_Wall[id.x] += Velocities_Wall[id.x] * deltaTime_Wall;
}

[numthreads(1, 1, 1)]
void ResetCompactionCounter_Wall(uint3 id : SV_DispatchThreadID)
{
    CompactionInfoBuffer_Wall[0] = int2(0, 0);
}

[numthreads(64, 1, 1)]
void CompactAndMoveParticles_Wall(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= numParticles_Wall)
        return;

    int particleType = Source_ParticleType_Wall[id.x][0];
    int removalFlag = Source_ParticleType_Wall[id.x][1];
    
    // Compaction Step...
    uint newIndex;
    if (removalFlag != -1 && particleType > 0)
    {
        InterlockedAdd(CompactionInfoBuffer_Wall[0][1], 1, newIndex);

        float2 pos = Source_Positions_Wall[id.x];
        float2 vel = Source_Velocities_Wall[id.x];
    
        RemovedParticlesBuffer_Wall[newIndex] = float4((float) particleType, pos.x, vel.x, vel.y);
    }
    else
    {
        //Increment counter for staying particles
        InterlockedAdd(CompactionInfoBuffer_Wall[0][0], 1, newIndex);
        
        // Assemble the struct and write it once for the kept particle
        ParticleData p;
        p.position = Source_Positions_Wall[id.x];
        p.predictedPosition = Source_PredictedPositions_Wall[id.x];
        p.velocity = Source_Velocities_Wall[id.x];
        p.particleType = Source_ParticleType_Wall[id.x];
        p.particleType.y = -1; // Reset removal flag
        p.collision = int4(-1, -1, -1, -1);
        p.density = Source_Densities_Wall[id.x];
        p.gravityScale = Source_GravityScales_Wall[id.x];
        p.padding = 0;
        
        SortTarget_Data_Wall[newIndex] = p;
    }
}

[numthreads(256, 1, 1)]
void CopyParticleTypeBuffer_Wall(uint3 id : SV_DispatchThreadID)
{
    // Use the existing global 'numParticles' constant for the check.
    if (id.x >= numParticles_Wall)
    {
        return;
    }
    
    CopiedParticleTypeBuffer_Destination_Wall[id.x] = OriginalParticleTypeBuffer_Source_Wall[id.x];
}

[numthreads(256, 1, 1)]
void ClearRemovedParticlesBuffer_Wall(uint3 id : SV_DispatchThreadID)
{
    RemovedParticlesBuffer_Wall[id.x] = float4(-1, -1, -1, -1);
}

[numthreads(256, 1, 1)]
void ClearObstacleGrid_Wall(uint3 id : SV_DispatchThreadID)
{
    uint totalCells = (uint) (obstacleGridDims_Wall.x * obstacleGridDims_Wall.y);
    if (id.x >= totalCells)
        return;
    ObstacleGridCounts_Wall[id.x] = 0;
}

[numthreads(64, 1, 1)]
void BuildObstacleGrid_Wall(uint3 id : SV_DispatchThreadID)
{
    uint obstacleIndex = id.x;
    if (obstacleIndex >= (uint) numObstacles_Wall)
        return;

    Obstacle obstacle = ObstaclesBuffer_Wall[obstacleIndex];
    float4 aabb = obstacle.aabb;

    // Find the min/max cells this obstacle overlaps
    int2 minCell = (int2) floor(aabb.xy / obstacleGridCellSize_Wall);
    int2 maxCell = (int2) floor(aabb.zw / obstacleGridCellSize_Wall);

    // Loop through all cells the obstacle touches
    for (int y = minCell.y; y <= maxCell.y; y++)
    {
        for (int x = minCell.x; x <= maxCell.x; x++)
        {
            int2 cellCoords = int2(x, y);
            // Ensure cell is within grid bounds
            if (cellCoords.x >= 0 && cellCoords.x < obstacleGridDims_Wall.x && cellCoords.y >= 0 && cellCoords.y < obstacleGridDims_Wall.y)
            {
                uint cellIndex = (uint) (cellCoords.y * obstacleGridDims_Wall.x + cellCoords.x);
                
                // Atomically increment this cell's counter to get our personal write slot (e.g., 0, 1, 2...)
                uint writeIndex;
                InterlockedAdd(ObstacleGridCounts_Wall[cellIndex], 1, writeIndex);

                // If we are not past the max-per-cell limit, write our obstacle ID
                if (writeIndex < (uint) maxObstaclesPerCell_Wall)
                {
                    ObstacleGrid_Wall[cellIndex * maxObstaclesPerCell_Wall + writeIndex] = obstacleIndex;
                }
            }
        }
    }
}